#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

base_path = File.expand_path('../lib', __dir__)

if File.exist?(base_path)
  require_relative '../lib/shale/schema'
else
  require 'shale/schema'
end

params = {}

ARGV << '-h' if ARGV.empty?

OptionParser.new do |opts|
  opts.banner = "Usage: shaleb [options]\nexample: shaleb -i data_model.rb -c MyRoot"

  opts.on('-i INPUT', '--input', 'Input file')
  opts.on('-o OUTPUT', '--output', 'Output file (defaults to STDOUT)')
  opts.on('-c CLASS', '--class CLASS', 'Shale model class name')
  opts.on('-f FORMAT', '--format FORMAT', 'Schema format: JSON (default), XML')
  opts.on('-p', '--pretty', 'Pretty print generated schema')

  opts.on('-v', '--version', 'Show version') do
    puts "shaleb version #{Shale::VERSION}"
    exit
  end
end.parse!(into: params)

input_path = File.expand_path(params[:input], Dir.pwd)

unless File.exist?(input_path)
  puts "File '#{input_path}' does not exist"
  exit
end

unless params[:class]
  puts 'Model class is required'
  exit
end

require input_path

klass = Object.const_get(params[:class])

if params[:format] == 'xml'
  if params[:output]
    base_name = File.basename(params[:output], File.extname(params[:output]))
    schemas = Shale::Schema.to_xml(klass, base_name, pretty: params[:pretty])

    schemas.map do |name, xml|
      File.write(File.expand_path(name, Dir.pwd), xml)
    end
  else
    schemas = Shale::Schema.to_xml(klass, pretty: params[:pretty])

    output = schemas.map do |name, xml|
      "<!-- #{name} -->\n#{xml}\n"
    end.join("\n")

    puts output
  end
else
  schema = Shale::Schema.to_json(klass, pretty: params[:pretty])

  if params[:output]
    output_path = File.expand_path(params[:output], Dir.pwd)
    File.write(output_path, schema)
  else
    puts schema
  end
end
